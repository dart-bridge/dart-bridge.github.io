<h1 id="ioc-container">IoC Container</h1>
<p class="lead">
The IoC Container is the backbone of the system. It's used to inject our dependencies
into the classes, resulting in testable and clean code, and a solid application
architecture.
</p>

<p>The methods in <a href="#/core/service-providers">Service Providers</a>, and the HTTP layer is
resolved through the Container. That means that we can simply <em>ask for</em> what
we need, and get an instance of that class.</p>
<p>As long as the <em>constructor</em> of that class <em>only contains other resolvable classes</em>, 
they too will be created.</p>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyOtherClass</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="typ">MyClass</span><span class="pln"> dependency</span><span class="pun">;</span><span class="pln">

  </span><span class="typ">MyOtherClass</span><span class="pun">(</span><span class="typ">MyClass</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">dependency</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyServiceProvider</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">ServiceProvider</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  load</span><span class="pun">(</span><span class="typ">MyOtherClass</span><span class="pln"> dependency</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    print</span><span class="pun">(</span><span class="pln">dependency</span><span class="pun">.</span><span class="pln">dependency </span><span class="kwd">is</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">);</span><span class="pln"> </span><span class="com">// true</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<h2 id="interacting-with-the-container">Interacting with the Container</h2>
<p class="lead">
If we inject the container itself, we can interact with it. This is the whole
purpose of the Service Providers, as you can learn about 
<a href="#/core/service-providers">here</a>.
</p>

<p>Create an instance of a class, and resolve all its dependencies with the <code>make</code> method.</p>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="typ">MyClass</span><span class="pln"> instance </span><span class="pun">=</span><span class="pln"> container</span><span class="pun">.</span><span class="pln">make</span><span class="pun">(</span><span class="typ">MyClass</span><span class="pun">);</span></code></pre>
<p>If you have an interface in your app, you'll want the classes depending on that module
to inject the interface, not an implementation. You can tell the container to
resolve the interface to an implementation, so that you have the choice of what
implementation to use located in a single place. Use the <code>bind</code> method.</p>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="pln">container</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="typ">MyAbstractClass</span><span class="pun">,</span><span class="pln"> </span><span class="typ">MyImplementation</span><span class="pun">);</span><span class="pln">

print</span><span class="pun">(</span><span class="pln">container</span><span class="pun">.</span><span class="pln">make</span><span class="pun">(</span><span class="typ">MyAbstractClass</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> </span><span class="typ">MyImplementation</span><span class="pun">);</span><span class="pln"> </span><span class="com">// true</span></code></pre>
<p>If you need one instance of a class to be used throughout your app, you can use the
<code>singleton</code> method.</p>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="typ">MyClass</span><span class="pln"> instance </span><span class="pun">=</span><span class="pln"> container</span><span class="pun">.</span><span class="pln">make</span><span class="pun">(</span><span class="typ">MyClass</span><span class="pun">);</span><span class="pln">

container</span><span class="pun">.</span><span class="pln">singleton</span><span class="pun">(</span><span class="pln">instance</span><span class="pun">);</span><span class="pln">

</span><span class="com">// When your instance is an implementation of an interface</span><span class="pln">
container</span><span class="pun">.</span><span class="pln">singleton</span><span class="pun">(</span><span class="pln">instance</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">as</span><span class="pun">:</span><span class="pln"> </span><span class="typ">MyInterface</span><span class="pun">);</span></code></pre>
<p>To resolve a method and resolve its arguments, use the <code>resolve</code> method.</p>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="pln">container</span><span class="pun">.</span><span class="pln">resolve</span><span class="pun">(</span><span class="pln">instance</span><span class="pun">.</span><span class="pln">method</span><span class="pun">);</span></code></pre>

