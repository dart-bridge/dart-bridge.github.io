<dom-module id="doc-middleware"><template><doc-page><h1 id="middleware-small-bridge-http-small-">Middleware <small>bridge.http</small></h1>
<p class="lead">
Bridge both provide a <code>Middleware</code> class that can be extended, and supports Shelf Middleware directly. Just use 
the <code>addMiddleware</code> method on the <code>Server</code> class.
</p>

<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="pln">server</span><span class="pun">.</span><span class="pln">addMiddleware</span><span class="pun">(</span><span class="pln">middleware</span><span class="pun">);</span></code></pre>
<p>Since the order of the middleware can not be relied upon, hijacking request-middleware must be explicitly prepended
to the beginning of the middleware list. Use the <code>highPriority</code> named flag.</p>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="pln">server</span><span class="pun">.</span><span class="pln">addMiddleware</span><span class="pun">(</span><span class="pln">middleware</span><span class="pun">,</span><span class="pln"> highPriority</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span></code></pre>
<h2 id="bridge-middleware">Bridge Middleware</h2>
<p>The <code>Middleware</code> abstract class can optionally implement one or both of the methods <code>request</code> and <code>response</code>.
Both is backed by the <a href="#/docs/core/service-container">Service Container</a>, and can return anything, like the
<a href="#/docs/http/router">route handlers</a>. The corresponding <code>shelf.Request</code> or <code>shelf.Response</code> can be injected.</p>
<h3 id="-request-"><code>request</code></h3>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyRequestMiddleware</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  request</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">'Hello, world!'</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="pln">server</span><span class="pun">.</span><span class="pln">addMiddleware</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MyRequestMiddleware</span><span class="pun">());</span></code></pre>
<p>Every request going into server will now return a response with the body <code>"Hello, world!"</code>. The middleware queue
will be continued depending on the return value of the return value of <code>request</code>:</p>
<ul>
<li><code>null</code> or <code>Future&lt;null&gt;</code> – The request will be passed on to the next middleware in the queue.</li>
<li><code>shelf.Request</code> or <code>Future&lt;shelf.Request&gt;</code> – The new (or modified) request will be passed to the next middleware
in the queue.</li>
<li><code>shelf.Response</code> or <code>Future&lt;shelf.Response&gt;</code> – The response will be returned, and the middleware queue is canceled.</li>
<li>Any other value will be cast to a <code>String</code> or JSON encodable format and returned as a <code>shelf.Response</code>, and the
middleware queue is canceled.</li>
</ul>
<h3 id="-response-"><code>response</code></h3>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyResponseMiddleware</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  response</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">'&lt;h1&gt;Overriding response&lt;/h1&gt;'</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<pre><code class="prettyprint lang-dart prettyprinted" data-lang="dart" style=""><span class="pln">server</span><span class="pun">.</span><span class="pln">addMiddleware</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MyResponseMiddleware</span><span class="pun">());</span></code></pre>
<p>Every request will now go through the router and the application, but be replaced by the <em>Overriding response</em>
heading. The <code>shelf.Response</code> passed into the next middleware in the queue, depends on the return value of the
<code>response</code> method:</p>
<ul>
<li><code>null</code> or <code>Future&lt;null&gt;</code> – The original response will be passed on to the next middleware in the queue.</li>
<li><code>shelf.Response</code> or <code>Future&lt;shelf.Response&gt;</code> – The new (or modified) response will be passed to the next middleware
in the queue.</li>
<li>Any other value will be cast to a <code>String</code> or JSON encodable format and returned as a <code>shelf.Response</code>, and passed
to the next middleware in the queue.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> the same <code>Middleware</code> can implement both methods, and the same instance will be shared for all
requests/responses.</p>
</blockquote>

</doc-page></template><script>Polymer({})</script></dom-module>